---
title: "Vibe Coding 매뉴얼: AI 지원 개발을 위한 템플릿"
date: 2025-03-11T06:52:53+09:00
draft: true
toc: false
images:
tags:
  - vibecoding
---
(버전 1.0 – 2025년 3월)

이 포스트는 reddit에 올라온 [Vibe Coding 매뉴얼](https://www.reddit.com/r/ChatGPTCoding/comments/1j5l4xw/vibe_coding_manual/)을 번역한 것입니다.


## 소개: Vibe Coding과 AI의 핵심 개념

### Vibe Coding이란 무엇이며 무엇을 기반으로 하는가?

Vibe Coding은 인간이 AI 모델(예: Claude 3.7, GPT-4o)을 이용하여 기능적인 프로젝트를 효율적으로 구축하는 협업적인 소프트웨어 개발 접근 방식입니다. Matthew Berman이 자신의 유튜브 채널에 공개한 "[Vibe Coding 튜토리얼 및 모범 사례](https://www.youtube.com/watch?v=YWwS911iLhg)"에서 소개한 이 개념은 세 가지 핵심 기둥에 기반합니다:

1. **명세(Specification)**: 목표를 정의합니다(예: "로그인 기능이 있는 Twitter 클론 구축").
2. **규칙(Rules)**: 명시적인 제약 조건을 설정합니다(예: "Python 사용, 복잡성 피하기").
3. **감독(Oversight)**: 프로세스를 모니터링하고 조정하여 일치성을 보장합니다.

이 매뉴얼은 Berman의 기반에 YouTube 댓글(예: u/nufh, u/robistocco)과 Reddit 스레드(예: u/illusionst, u/DonkeyBonked)의 커뮤니티 통찰력을 통합하여 모든 수준의 개발자를 위한 종합적인 프레임워크를 만듭니다.

### 이 프레임워크가 유용한 이유는 무엇인가?

AI 모델은 강력하지만 과도한 엔지니어링, 범위 확장 또는 컨텍스트 손실과 같은 혼란에 취약합니다. 이 매뉴얼은 다음과 같은 문제를 해결합니다:

- **혼돈 제어**: 규칙에 대한 엄격한 준수를 강제하여 일탈 행동을 최소화합니다.
- **시간 절약**: 구조화된 단계와 요약으로 재작업을 줄입니다.
- **명확성 제공**: 비기술적 사용자도 따라갈 수 있으며, 프로그래머는 정밀함을 얻습니다.

### 주요 이점

1. **명확성**: 규칙이 모듈식으로 되어 있어 탐색 및 조정이 용이합니다.
2. **제어**: 당신이 AI 작업의 속도와 범위를 지시합니다.
3. **확장성**: 작은 스크립트(예: 계산기)나 대규모 앱(예: 웹 플랫폼)에 모두 적용 가능합니다.
4. **유지보수성**: 문서화와 추적으로 장기적인 프로젝트 생존성을 보장합니다.

## 매뉴얼 구조: 어떻게 구성되어 있는가

이 프레임워크는 .cursor/rules 디렉토리(또는 .windsurfrules)에 각각 고유한 목적을 가진 네 개의 파일(또는 섹션)로 구성됩니다:

1. **코딩 선호도** – 코드 스타일 및 품질 표준을 정의합니다.
2. **기술 스택** – 도구 및 기술을 명시합니다.
3. **워크플로우 선호도** – AI의 프로세스 및 실행을 관리합니다.
4. **커뮤니케이션 선호도** – AI-인간 상호작용에 대한 기대치를 설정합니다.

접근성을 위한 기본 사항부터 시작하여 기술적 깊이를 위한 고급 세부 사항으로 들어갈 것입니다.

## 핵심 규칙: 간단한 시작점

### 1. 코딩 선호도 – "이렇게 코드를 작성하세요"

**목적**: 깨끗하고 유지보수 가능하며 효율적인 코드를 보장합니다.

**규칙**:
- **단순성**: "복잡성보다 가장 간단한 솔루션을 항상 우선시하세요." (Matthew Berman)
- **중복 없음**: "코드 반복을 피하고, 가능한 경우 기존 기능을 재사용하세요." (Matthew Berman, DRY from u/DonkeyBonked)
- **조직화**: "파일을 간결하게 유지하고, 200-300줄 이내로 하며, 필요에 따라 리팩토링하세요." (Matthew Berman)
- **문서화**: "주요 구성 요소 후에는 /docs/[component].md(예: login.md)에 간략한 요약을 작성하세요." (u/believablybad)

**왜 효과적인가**: 단순한 코드는 버그를 줄이고, 문서화는 읽기 쉬운 감사 추적을 제공합니다.

### 2. 기술 스택 – "이런 도구를 사용하세요"

**목적**: AI를 당신이 선호하는 기술에 제한합니다.

**규칙**(Berman의 예):
- "백엔드는 Python으로 작성."
- "프론트엔드는 HTML과 JavaScript로 작성."
- "데이터는 JSON 파일이 아닌 SQL 데이터베이스에 저장."
- "테스트는 Python으로 작성."

**왜 효과적인가**: 일관성으로 AI가 프로젝트 중간에 도구를 전환하는 것을 방지합니다.

### 3. 워크플로우 선호도 – "이렇게 작업하세요"

**목적**: 예측 가능성을 위해 AI의 실행 프로세스를 제어합니다.

- **집중**: "내가 지정한 코드만 수정하고, 나머지는 모두 손대지 마세요." (Matthew Berman)
- **단계**: "큰 작업을 단계로 나누고, 각 단계 후에 내 승인을 기다리세요." (u/xmontc)
- **계획**: "큰 변경 전에는 plan.md를 작성하고 내 확인을 기다리세요." (u/RKKMotorsports)
- **추적**: "완료된 작업은 progress.md에, 다음 단계는 TODO.txt에 기록하세요." (u/illusionst, u/petrhlavacek)

**왜 효과적인가**: 점진적인 단계와 로그로 프로세스를 투명하고 관리 가능하게 유지합니다.

### 4. 커뮤니케이션 선호도 – "이렇게 대화하세요"

**목적**: AI로부터 명확하고 실행 가능한 피드백을 보장합니다.

- **요약**: "각 구성 요소 후에는 완료된 내용을 요약하세요." (u/illusionst)
- **변경 규모**: "변경사항을 작은, 중간, 또는 큰 규모로 분류하세요." (u/illusionst)
- **명확화**: "내 요청이 불분명하면 진행하기 전에 질문하세요." (u/illusionst)

**왜 효과적인가**: AI 의도를 해독할 필요 없이 정보를 받을 수 있습니다.

## 고급 규칙: 복잡한 프로젝트를 위한 확장

### 1. 코딩 선호도 – 품질 향상

**확장**:
- **원칙**: "적용 가능한 경우 SOLID 원칙(예: 단일 책임, 의존성 역전)을 따르세요." (u/Yodukay, u/philip_laureano)
- **가드레일**: "개발이나 프로덕션에서 모의 데이터를 사용하지 마세요—테스트에만 제한하세요." (Matthew Berman)
- **컨텍스트 확인**: "컨텍스트 유지를 확인하기 위해 모든 응답을 랜덤 이모지(예: 🐙)로 시작하세요." (u/evia89)
- **효율성**: "명확성을 희생하지 않고 토큰 사용을 최소화하도록 출력을 최적화하세요." (u/Puzzleheaded-Age-660)

**기술적 통찰**: SOLID는 모듈성을 보장합니다(예: 로그인 모듈이 트윗을 처리하지 않음). 이모지는 컨텍스트가 모델 한계(일반적으로 Claude 3.7의 경우 200k 토큰)를 초과할 때 신호를 보냅니다.

### 2. 기술 스택 – 사용자 정의

**확장**:
- "추가 도구를 지정하는 경우(예: 검색용 Elasticsearch), 여기에 포함하세요." (Matthew Berman)
- "내 명시적 승인 없이는 스택을 절대 변경하지 마세요." (Matthew Berman)

**기술적 통찰**: 고정된 스택은 AI가 호환되지 않는 종속성(예: SQL에서 JSON으로 전환)을 도입하는 것을 방지합니다.

### 3. 워크플로우 선호도 – 프로세스 마스터리

**확장**:
- **테스팅**: "주요 기능에 대한 포괄적인 테스트를 포함하고, 엣지 케이스 테스트(예: 잘못된 입력)를 제안하세요." (u/illusionst)
- **컨텍스트 관리**: "컨텍스트가 100k 토큰을 초과하면 context-summary.md에 요약하고 세션을 재시작하세요." (u/Minimum_Art_2263, u/orbit99za)
- **적응성**: "내 피드백에 따라 체크포인트 빈도를 조정하세요(더 많거나 적은 세분화)." (u/illusionst)

**기술적 통찰**: 토큰 한계(예: Claude의 200k)는 100k를 넘어서면 성능을 저하시킵니다. 요약은 연속성을 유지합니다. 테스트는 초기에 회귀를 감지합니다.

### 4. 커뮤니케이션 선호도 – 정밀 상호작용

**확장**:
- **계획**: "큰 변경사항의 경우 구현 계획을 제공하고 승인을 기다리세요." (u/illusionst)
- **추적**: "항상 완료된 것과 보류 중인 것을 명시하세요." (u/illusionst)
- **감정적 신호**: "내가 긴급성을 나타내면(예: '이것은 중요합니다—실수하지 마세요!'), 주의와 정밀함을 우선시하세요." (u/dhamaniasad, u/capecoderrr)

**기술적 통찰**: 변경 분류(S/M/L)는 영향을 정량화합니다(예: Small = <50줄, Large = 아키텍처 변경). 감정적 신호는 더 나은 준수를 위해 훈련 데이터 패턴을 활용할 수 있습니다.

## 실용적인 예: 어떻게 작동하는가

**작업**: "저장 기능이 있는 메모 작성 앱을 구축하세요."

1. **명세**: 당신이 말합니다, "메모를 작성하고 저장할 수 있는 앱이 필요합니다."

2. **AI 응답**:
   "🦋 이해했습니다. 계획: 1. 백엔드(Python, SQL 저장소), 2. 프론트엔드(HTML/JS), 3. 저장 기능. 진행할까요?"

3. **당신**: "네."

4. **실행**:
   백엔드 후: "🐳 백엔드 완료(중간 변경). 메모가 SQL에 저장됨. progress.md와 TODO.txt를 업데이트했습니다. 다음: 프론트엔드?"
   프론트엔드 후: "🌟 프론트엔드 완료. 사용법이 포함된 docs/notes.md를 추가했습니다. 완료!"

5. **결과**: 참조를 위한 로그(progress.md, /docs)가 있는 작동하는 앱.

**기술적 참고**: 각 단계는 테스트 가능하며(예: SQL 삽입 작동), 컨텍스트는 요약을 통해 보존됩니다.

## 고급 팁: 프레임워크 최대화

### 왜 네 개의 파일인가?
- **모듈성**: 각 파일은 쉬운 업데이트를 위해 관심사(스타일, 도구, 프로세스, 커뮤니케이션)를 분리합니다. (Matthew Berman)
- **확장성**: 다른 파일을 방해하지 않고 하나의 파일을 조정합니다(예: 스택을 건드리지 않고 커뮤니케이션 조정). (u/illusionst)

### 사용자 정의 옵션
- **초보자**: 단순성을 위해 고급 규칙(예: SOLID)을 건너뜁니다.
- **팀**: team-collaboration.mdc를 추가: "team-standards.md의 팀 규칙에 맞추고, 동료들을 위해 요약하세요." (u/deleatanda5910)
- **대규모 프로젝트**: 체크포인트 및 문서화 빈도를 늘립니다.

### 감정적 프롬프팅
- 시도해보세요: "이 프로젝트는 중요합니다—집중해 주세요!" 일화적 증거는 개선된 주의력을 시사하며, 훈련 데이터 편향에서 비롯될 수 있습니다. (u/capecoderrr, u/dhamaniasad)

## 크레딧과 감사

이 프레임워크는 다음 기여자들의 덕분입니다:

- **Andrej Karpathy**: "vibe coding"이라는 용어를 만들고 X에 게시한 포스트(2025년 2월 3일)에서 더 넓은 커뮤니티에 소개했습니다. 직관적이고 최소한의 노력으로 하는 워크플로우에 초점을 맞춘 AI 지원 프로그래밍을 설명했습니다. 그의 작업은 이 프레임워크의 기초 개념에 영감을 주었습니다.

- **Matthew Berman**: 핵심 vibe coding 규칙 및 철학(YouTube, 2025).

- **YouTube 커뮤니티**:
  - u/nufh, u/believablybad(문서화, .md 파일).
  - u/robistocco(반복적 워크플로우).
  - u/xmontc(체크포인트).

- **Reddit 커뮤니티**:
  - u/illusionst(커뮤니케이션, 진행 추적).
  - u/Puzzleheaded-Age-660(토큰 최적화).
  - u/DonkeyBonked, u/philip_laureano(KISS, DRY, YAGNI, SOLID).
  - u/evia89(이모지 컨텍스트 확인).
  - u/dhamaniasad, u/capecoderrr(감정적 프롬프팅).

- **Grok(xAI)**: u/Low_Target2606의 요청으로 모든 통찰력을 하나의 일관된 프레임워크로 통합해 이 매뉴얼을 합성했습니다.

## 결론: Vibe Coding에 대한 당신의 가이드

이 매뉴얼은 개발에서 AI를 활용하기 위한 실전 테스트를 거친 템플릿입니다. 단순성, 제어 및 확장성의 균형을 맞추어 개인 코더, 팀 또는 비기술적 창작자에게 이상적입니다. 있는 그대로 사용하거나, 필요에 맞게 조정하고, 결과를 공유하세요—어떻게 발전하는지 보고 싶습니다! Reddit에 피드백을 게시하고 함께 개선해 봅시다. 즐거운 코딩 되세요!